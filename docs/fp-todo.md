---
id: fp-todo
title: TODO
---

> TODO Tagless Final Encoding

* [Finally Tagless, Partially Evaluated](http://okmij.org/ftp/tagless-final/JFP.pdf) (Paper)
* [Typed Tagless Final Interpreters](http://okmij.org/ftp/tagless-final/course/lecture.pdf) (Paper)
* [Exploring Tagless Final pattern for extensive and readable Scala code](https://blog.scalac.io/exploring-tagless-final.html)
* [Structuring Functional Programs with Tagless Final](https://www.becompany.ch/en/blog/2018/06/21/tagless-final)
* [Free and tagless compared](https://softwaremill.com/free-tagless-compared-how-not-to-commit-to-monad-too-early)
* [Functional Web Services with Final Encoding](https://speakerdeck.com/markus1189/functional-web-services-with-final-encoding)
* [Tagless Final algebras and Streaming](https://typelevel.org/blog/2018/05/09/tagless-final-streaming.html)
* [MTL-style program composition](https://www.reddit.com/r/scala/comments/90jk2u/mtlstyle_programming/e2qze0c)
* [Advanced Tagless Final - Saying Farewell to Free](https://www.slideshare.net/LukaJacobowitz/advanced-tagless-final-saying-farewell-to-free)
* [Introduction to Tagless final](http://www.beyondthelines.net/programming/introduction-to-tagless-final)
* [From Object Algebras to Finally Tagless Interpreters](https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/)
* [The Death of Final Tagless](https://skillsmatter.com/skillscasts/13247-scala-matters) (Video)

> TODO

* [First steps with monads in Scala](https://darrenjw.wordpress.com/2016/04/15/first-steps-with-monads-in-scala)
* [Demystifying the Monad in Scala](https://medium.com/@sinisalouc/demystifying-the-monad-in-scala-cc716bb6f534)
* [Cooking with Monads](https://www.becompany.ch/en/blog/2016/11/08/cooking-with-monads)
* [Functors, Applicatives, And Monads In Pictures](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)
* [Hands-on category theory](https://earldouglas.com/talks/scala-cats/tutorial.html)
* Incremental Purity [[slide](https://git.io/fp017)|[code](https://git.io/fp01d)] (Meetup)
* [Functional Composition](https://benmosheron.gitlab.io/blog/2018/12/24/functional-composition.html)

> TODO free monad

* [Stack Safety for Free](http://functorial.com/stack-safety-for-free/index.pdf) (Paper)
* [Stackless Scala With Free Monads](http://blog.higher-order.com/assets/trampolines.pdf) (Paper)
* [Free monads - what? and why?](https://softwaremill.com/free-monads)
* [Free Monad examples](https://github.com/kenbot/free)
* [Overview of free monad in cats](https://blog.scalac.io/2016/06/02/overview-of-free-monad-in-cats.html)

> TODO review

**FP resources**

* [The Essence of the Iterator Pattern](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf) (Paper)
* [Applicative programming with effects](http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf) (Paper)

* [Generalized type constraints in Scala (without a PhD)](http://blog.bruchez.name/2015/11/generalized-type-constraints-in-scala.html)
* [Scala Tagged types](http://www.vlachjosef.com/tagged-types-introduction)
* Modern Functional Programming [[part-1](http://degoes.net/articles/modern-fp)|[part-2](http://degoes.net/articles/modern-fp-part-2)]

* [Monadic IO: Laziness Makes You Free](https://underscore.io/blog/posts/2015/04/28/monadic-io-laziness-makes-you-free.html)
* [An IO monad for cats](https://typelevel.org/blog/2017/05/02/io-monad-for-cats.html)
* [Intro to Functional Game Programming](https://github.com/jdegoes/lambdaconf-2014-introgame)

* [Rethinking MonadError](https://typelevel.org/blog/2018/04/13/rethinking-monaderror.html)
* [Stackless Scala](http://www.marcoyuen.com/articles/2016/09/08/stackless-scala-1-the-problem.html)

* [Category Theory for Programmers](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface)
* [Scala's Modular Roots](http://lambdafoo.com/scala-syd-2015-modules)
* [Lens in scala](http://koff.io/posts/292173-lens-in-scala)
* [The Evolution of a Scala Programmer](https://medium.com/@olxc/the-evolution-of-a-scala-programmer-1b7a709fb71f)
* [Types: Never commit too early](https://www.sderosiaux.com/articles/2018/08/15/types-never-commit-too-early-part1/)

* [Law Enforcement using Discipline](https://typelevel.org/blog/2013/11/17/discipline.html)

* [Scala for generic programmers](http://ropas.snu.ac.kr/~bruno/papers/ScalaGeneric.pdf) (Paper)

**Patterns**

* [The Aux Pattern](https://gigiigig.github.io/posts/2015/09/13/aux-pattern.html)
* [Aux Pattern Evolution](http://www.vlachjosef.com/aux-pattern-evolution/)
* [Cake pattern](https://medium.com/@itseranga/scala-cake-pattern-e0cd894dae4e)
* [Magnet pattern](http://spray.io/blog/2012-12-13-the-magnet-pattern)
* `newtype` [The High Cost of AnyVal subclasses](https://failex.blogspot.com/2017/04/the-high-cost-of-anyval-subclasses.html)

**Other FP languages**

* [A practical introduction to functional programming](https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming)
* [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/chapters)
* [A Quick Tour of Haskell Syntax](http://prajitr.github.io/quick-haskell-syntax)
* [OCaml taste](https://ocaml.org/learn/taste.html)

**Blogs**

* [Typelevel](https://typelevel.org/blog)
* [Scalac](https://blog.scalac.io)
* [Signify](https://www.signifytechnology.com/blog)
* [Scala Times](https://scalatimes.com)
* [SoftwareMill](https://softwaremill.com/blog)
* [okmij](http://okmij.org/ftp/README.html)
* [Scala Love](https://scala.love)

**Videos**

* [The Making of an IO](https://www.youtube.com/watch?reload=9&v=g_jP47HFpWA)
* [Scalaz 8 VS Akka actors](https://www.youtube.com/watch?v=Eihz7kqn6mU&t=833s)
* [Move Over Free Monads: Make Way for Free Applicatives!](https://youtu.be/H28QqxO7Ihc)
* [Faculty of Khan](https://www.youtube.com/channel/UCGDanWUzNMbIV11lcNi-yBg/videos)
* [SystemFw - Talks](http://systemfw.org/talks.html)

> TODO Kleisli

*What is a Monad?*

Informally, a Monad is anything with a constructor and a flatMap method. A Monad is a mechanism for *sequencing computations*, all monads are functors but the opposite is not true.

A Monad is an implementation of one of the minimal sets of monadic combinators, satisfying the laws of associativity and identity

* unit and flatMap
* unit and compose
* unit, map and join

where the above are defined

```scala
def unit[A](a: => A): F[A]
def map[A, B](ma: F[A])(f: A => B): F[B]
def flatMap[A, B](ma: F[A])(f: A => F[B]): F[B]
def compose[A, B, C](f: A => F[B], g: B => F[C]): A => F[C]
def join[A](mma: F[F[A]]): F[A]

// Identity: compose(unit, f) = f = compose(f, unit)
// Associativity: compose(compose(f, g), h) = compose(f, compose(g, h))
```

A Monad provide a context for introducing and binding variables and performing variable substitution

```scala
object Monad {
  case class Id[A](value: A) {
    def map[B](f: A => B): Id[B] =
      Id(f(value))
    def flatMap[B](f: A => Id[B]): Id[B] =
      f(value)
  }

  val idMonad: Monad[Id] = new Monad[Id] {
    override def unit[A](a: => A): Id[A] =
      Id(a)

    override def flatMap[A, B](ma: Id[A])(f: A => Id[B]): Id[B] =
      ma.flatMap(f)
  }
}

Monad.Id("hello ").flatMap(a => Monad.Id("world").flatMap(b => Monad.Id(a + b)))

for {
  a <- Monad.Id("hello ")
  b <- Monad.Id("world")
} yield a + b

res: Monad.Id[String] = Id(hello world)
```

*What is a Semigroupal?*

A Semigroupal is a type class that allows to combine contexts. In contrast to flatMap, which imposes a strict order, Semigroupal parameters are independent of one another, which gives more freedom with respect to monads

```scala
trait Semigroupal[F[_]] {
  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]
}
```

*What is an Applicative?*

* all applicatives are functors
* all applicatives are a semigroupal
* all monads are applicative functors, viceversa is not true

```scala
// cats definition
trait Apply[F[_]] extends Semigroupal[F] with Functor[F] {
  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]
  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
    ap(map(fa)(a => (b: B) => (a, b)))(fb)
}

trait Applicative[F[_]] extends Apply[F] {
  def pure[A](a: A): F[A]
}

// red book definition
trait Applicative[F[_]] extends Functor[F] {
  // primitive combinators
  def map2[A, B, C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C]
  def unit[A](a: => A): F[A]

  // derived combinators
  def map[A, B](fa: F[A])(f: A => B): F[B] =
    map2(fa, unit(()))((a, _) => f(a))
  def traverse[A, B](as: List[A])(f: A => F[B]): F[List[B]] =
    as.foldRight(unit(List[B]()))((a, fbs) => map2(f(a), fbs)(_ :: _))
}
```

<!--

TODO Morphism, Endomorphism, Isomorphism
https://conorfennell.github.io/scala-zen/articles/functional-jargon.html#morphism

TODO
https://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala

Summary

* Semigroup: associativity
* Monoid: associativity + identity
* Functor: map
* Monad: any of 3 monadic laws (e.g. unit + flatMap) + associativity and identity (extends Functor)
* Applicative functor
* Traversable functor

* A function having the same argument and return type is sometimes called an endofunction

TODO Functor and Monad

* associative e.g. `x.flatMap(f).flatMap(g) == x.flatMap(a => f(a).flatMap(g))`
* monadic functions of types like `A => F[B]` are called Kleisli arrows

Laws
* Left and right identity
* Associativity
* Naturality of product

## Best practices and tips

```
# best practices
https://stackoverflow.com/questions/5827510/how-to-override-apply-in-a-case-class-companion

# type projector
https://typelevel.org/blog/2015/07/13/type-members-parameters.html

# jvm stack
https://www.artima.com/insidejvm/ed2/jvm8.html
https://alvinalexander.com/scala/fp-book/recursion-jvm-stacks-stack-frames
```
-->

<!--

Algebra = Operations + Types

e.g.
* create is an operation
* A and String is a type
* Db is a piece of Algebra that can be composed or extended

trait Db[F[_]] {
  def create[A]: F[String]
  def delete(id: String): F[Boolean]
}

Interpreter = "Implementation" of an Algebra

i.e. Materialization for specific type

---
they are alternatives:

(tagless) final encoding: typeclass
* ignore tagless
* final encoding: means that you can describe operations with functions

initial encoding: free monad
* you can describe operations with case classes

trait Db {
  case class Create[F[_], A](a: A)
  case class Delete[F[_]](id: String)
}

---

Tagless Final Encoding == MTL-style program composition

mtl is now is a final tagless encoding of common effects

The `mtl` (Monad Transformer library) library in haskell used to provide the concrete monad transformers types, which are now in `transformers`

Option, Either, IO are all effect/context/wrapper

-->
